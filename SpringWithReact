Step 1: Create a Spring API using Spring Boot

Step 2: Create a employee_table in oracle db as below:

create table EMPLOYEE_TABLE(
ID NUMBER    GENERATED BY DEFAULT ON NULL AS IDENTITY CONSTRAINT pk_employee_tb  primary key,
NAME VARCHAR2(255) CONSTRAINT NN_EMPLOYEE_NAME NOT NULL,
GENDER VARCHAR2(255) CONSTRAINT NN_EMPLOYEE_GENDER NOT NULL,
DEPARTMENT VARCHAR2(255) CONSTRAINT NN_EMPLOYEE_DEPARTMENT NOT NULL,
DOB DATE CONSTRAINT NN_EMPLOYEE_DOB NOT NULL
);
Application.properties
-----------------------------
spring.datasource.url=jdbc\:oracle\:thin\:@DESKTOP-BKM4C9J\:1521\:xe
spring.datasource.username=C\#\#PRASHANT
spring.datasource.password=PRASHANT
spring.datasource.driver-class-name=oracle.jdbc.OracleDriver
spring.jpa.database-platform=org.hibernate.dialect.Oracle10gDialect


Step 3: Setup Spring Boot + Hibernate for basic CRUD

Create a structure for the API
com.springboot.api.crudapi
-> Main Executbale file
com.springboot.api.crudapi.controller
-> Employee Controller
com.springboot.api.crudapi.dao
-> EmployeeDAO Interface
-> EmployeeDAOImp
com.springboot.api.crudapi.model
-> Employee model
com.springboot.api.crudapi.service
-> EmployeeService Interface
-> EmployeeServiceImp

Step 4: Program the model

Configure the application.properties
spring.datasource.url=jdbc:jdbc:oracle:thin:@DESKTOP-BKM4C9J:1521:xe
spring.datasource.username=C##PRASHANT
spring.datasource.password=PRASHANT

Step 5: Program the DAO
1. DAO is a Database Access Object design pattern uned in Java Oriented stacks where an interface is used to provide access to the DB.
2. Usage of DAO provides the logical sepearation of business logic from the persistence data logic.

First Declare the following functions in the Interface of EmaployeeDAO.java

// Get the list of employees
	List <Employee> get();
	
//Get the specifid employee with the id
Employee get(int id);
	
// Save the Employee
void save(Employee employee);
	
// Delete the employee with the ID
void delete(int id);

Second now use the EmployeeDAO interface to define the functions

Notes: 
1. Spring @Repository Annotation is a specialization of @Component annotation, so Spring Repository classes are autodetected by spring framework through classpath scanning
2. Spring repository is a very close to DAO pattern where DAO classes are responsible for providing CRUD operations on databatase tables.

In each implementation of the interace functions
private EntityManage entityManager;
We use Session currSession = entityManager.unwrap(Session.Class)

@Autowired
	private EntityManager entityManager;
	
	public List<Employee> get(){
		// Create a JPA session
		Session currSession = entityManager.unwrap(Session.class);
		// using Query class to select from employee table
		Query<Employee> query = currSession.createQuery("from Employee", Employee.class);
		// get the result of the query in the form of row
		List<Employee> list = query.getResultList();
		return list;
	}
	
	public Employee get(int id) {
		Session currSession = entityManager.unwrap(Session.class);
		Employee emp = currSession.get(Employee.class, id);
		return emp;
	}
	
	public void save(Employee employee) {
		Session currSession = entityManager.unwrap(Session.class);
		currSession.saveOrUpdate(employee);
	}
	
	public void delete(int id) {
		Session currSession = entityManager.unwrap(Session.class);
		Employee emp = currSession.get(Employee.class,id);
		currSession.delete(emp);
	}

Step 6: Define the service and implementation
The service class is used to mark a class as the service provider. They are used to define the bussiness logic away from teh controller.

The service class is used to interact with the DAO
@Autowired
	private EmployeeDAO employeeDAO;
	
	@Transactional
	public List<Employee> get(){
		return employeeDAO.get();
	}
	
	@Transactional
	public Employee get(int id) {
		return employeeDAO.get(id);
	}
	
	@Transactional
	public void save (Employee employee) {
		employeeDAO.save(employee);
	}
	
	@Transactional
	public void delete(int id) {
		employeeDAO.delete(id);
	}

Step 7: Define the controller
@RestController
@RequestMapping("/api")
public class EmployeeController {
	
	@Autowired
	private EmployeeService employeeService;
	
	@GetMapping("/employee")
	public List<Employee> get(){
		return employeeService.get();
	}
	
	@PostMapping("/employee")
	public Employee save(@RequestBody Employee employee) {
		employeeService.save(employee);
		return employee;
	}
	
	@GetMapping("/employee/{id}")
	public Employee get(@PathVariable int id) {
		return employeeService.get(id);
	}
	
	@DeleteMapping("/employee/{id}")
	public String delete(@PathVariable int id) {
		employeeService.delete(id);
		
		return "Employee removed with id:" +id;
	}
	
	@PutMapping("/employee")
	public Employee update(@RequestBody Employee employee) {
		employeeService.save(employee);
		return employee;
	}
	
}


Step 8: Build the application by adding in the Main
@SpringBootApplication(scanBasePackages = {"com.springboot.api.crudpai.service","com.springboot.api.crudapi.controller","com.springboot.api.crudapi.dao","com.springboot.api.crudapi.model","com.springboot.api.crudpai.service"})

Step 9: Open postman
create a get request: 
http://localhost:8080/api/employee

For posting request
Go to body change the type to JSON and send the request
{
        "name": "DEVAL",
        "department": "DEV",
        "dob": "1993-08-29",
        "gender": "MALE"
}

-------------Backend Completed-----------------------------------------

-------------Frontend Start----------------------------------------------
npx create-react-app frontend
npm install react-router
npm install @material-ui/core
npm install @material-ui/icons 

Structure of Application Frontend
----------------------------------------------



Notes for React:
@material-ui/core contains the following components
Container
-


Using Hooks React.useState
lets us add React state to function components

;//Status: {message}
